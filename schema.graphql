# This entity will have only once instance and will be used to cache protocol-wide data like list of tokens. ID is 0
type ProtocolStats @entity {
  id: ID!
  tokens: [Token!]!
  totalUsers: BigInt!
}

type SmartToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  # standard: String
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken") # possibly v2 converter, how to handle?
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  # shortestQuickBuyPath: [QuickBuyPathMember!]
  # converterWithShortestQuickBuyPath: Converter
  owner: Bytes!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

type TokenSmartToken @entity {
  id: ID! # ID is token address + smartToken address
  token: Token!
  smartToken: SmartToken!
}

type ConverterRegistry @entity {
  id: ID!
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: Bytes! # address
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

type Transaction @entity {
  # txn hash
  id: ID!
  # block txn was included in
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  # gasUsed: BigInt!
  gasPrice: BigInt!
  # tx index
  index: BigInt!
  from: Bytes!
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

type User @entity {
  id: ID! @unique
  swaps: [Swap!] @derivedFrom(field: "user")
  numSwaps: Int!
  liquidityHistory: [UserLiquidityHistory!] @derivedFrom(field: "user")
  trades: [Trade!] @derivedFrom(field: "user")
  borrows: [Borrow!] @derivedFrom(field: "user")
  liquidations: [Liquidate!] @derivedFrom(field: "user")
  loans: [Loan!] @derivedFrom(field: "user")
  lendingHistory: [UserLendingHistory!] @derivedFrom(field: "lender")
  dividendsCollected: [DividendsCollected!] @derivedFrom(field: "receiver")
  stakeHistory: [UserStakeHistory!] @derivedFrom(field: "user")
  feesEarnedHistory: [FeesEarnedHistory!] @derivedFrom(field: "user")
  # vestedTokensWithdrawn: [TokensWithdrawn!] @derivedFrom(field: "receiver")
  vestingContracts: [VestingContract!] @derivedFrom(field:"user")

  availableTradingRewards: BigInt!
  availableRewardSov: BigInt!

  # tokenSwapTotals: [UserTokenSwapTotal!]
  # smartTokenBalances: [UserSmartTokenBalance!]
  # liquidityProvided: [LiquidityProvided]
}

type UserLendingHistory @entity {
  id: ID! # user address
  lender: User!
  type: String! # Lend or Unlend
  lendingPool: LendingPool!
  asset: Token!
  amount: BigInt!
}

type Token @entity {
  id: ID! @unique
  name: String
  symbol: String
  decimals: Int
  version: Int
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  lastPriceBtc: BigDecimal! # TODO: Change to big decimal - or not, maybe keep in BigInt
  lastPriceUsd: BigDecimal! # TODO: Change to big decimal
  # marketCap: BigInt!
  # circulatingSupply: BigInt!
  currentConverterRegistry: ConverterRegistry
}

type PoolToken @entity {
  id: ID! #address
  name: String
  symbol: String
  decimals: Int
  converters: LiquidityPoolToken! @derivedFrom(field: "poolToken") #TODO: Does this need a many-to-many relationship?
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

type Swap @entity {
  id: ID! # transaction hash of the swap
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  numConversions: Int!
  fromToken: Token! 
  toToken: Token!
  fromAmount: BigInt!
  toAmount: BigInt!
  rate: BigDecimal!
  user: User!
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  timestamp: BigInt!
}

type LiquidityPool @entity {
  id: ID!
  type: Int
  version: Int
  smartToken: SmartToken
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: BigInt
  weight: BigInt
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: BigInt
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: BigInt!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

type LiquidityPoolToken @entity {
  id: ID! # ID is token address + liquidityPool address
  token: Token!
  liquidityPool: LiquidityPool!
  poolToken: PoolToken!
}

type TokenPoolToken @entity {
  id: ID! # ID is token address + poolToken address
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

# Loans

type Loan @entity {
  id: ID! # ID is LoanId
  loanToken: Token!
  collateralToken: Token!
  isTrade: Boolean!
  isBorrow: Boolean!
  startTimestamp: BigInt!
  endTimestamp: BigInt!
  borrowedAmount: BigInt!
  collateralAmount: BigInt!
  startRate: BigInt!
  isOpen: Boolean!
  user: User
  trade: Trade
  borrow: Borrow
  closeWithSwaps: [CloseWithSwap!]
  closewithDeposits: [CloseWithDeposit!]
  liquidates: [Liquidate!]
  depositCollateral: [DepositCollateral!]
  realizedPnL: BigInt
}

# Lending

type LendingPool @entity {
  id: ID! # ID is lending pool address
}


#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: Bytes! # address
  _owner: Bytes! # address
  timestamp: BigInt!
  transaction: Transaction!
}

type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenAdded @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type PriceDataUpdate @entity {
  id: ID!
  _connectorToken: Bytes! # address
  _tokenSupply: BigInt! # uint256
  _connectorBalance: BigInt! # uint256
  _connectorWeight: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type UserLiquidityHistory @entity {
  id: ID!
  user: User!
  type: String!
  provider: Bytes! # address
  reserveToken: Token! # address
  amount: BigInt! # uint256
  newBalance: BigInt! # uint256
  newSupply: BigInt! # uint256
  timestamp: BigInt!
  liquidityPool: LiquidityPool!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Activation @entity {
  id: ID!
  _type: Int! # uint16
  _anchor: Bytes! # address
  _activated: Boolean! # bool
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: Bytes! # address
  _amount: BigInt! # uint256
  _return: BigInt! # uint256
  _conversionFee: BigInt! # int256
  _protocolFee: BigInt! # int256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

type TokenRateUpdate @entity {
  id: ID!
  _token1: Bytes! # address
  _token2: Bytes! # address
  _rateN: BigInt! # uint256
  _rateD: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type ConversionFeeUpdate @entity {
  id: ID!
  _prevFee: BigInt! # uint32
  _newFee: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawFees @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  protocolFeeAmount: BigInt! # uint256
  wRBTCConverted: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Approval @entity {
  id: ID!
  owner: Bytes! # address
  spender: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  value: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Sovryn Protocol Events
type Borrow @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  newPrincipal: BigInt! # uint256
  newCollateral: BigInt! # uint256
  interestRate: BigInt! # uint256
  interestDuration: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type CloseWithDeposit @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  closer: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type CloseWithSwap @entity {
  id: ID!
  user: Bytes! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  closer: Bytes! # address
  positionCloseSize: BigInt! # uint256
  loanCloseAmount: BigInt! # uint256
  exitPrice: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type DepositCollateral @entity {
  id: ID!
  loanId: Loan! # bytes32
  depositAmount: BigInt! # uint256
  rate: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type EarnReward @entity {
  id: ID!
  receiver: User! # address
  token: Token! # address
  loanId: Loan! # bytes32
  feeRebatePercent: BigInt! # uint256
  amount: BigInt! # uint256
  basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Liquidate @entity {
  id: ID!
  user: User! # address
  liquidator: Bytes! # address
  loanId: Loan! # bytes32
  lender: Bytes! # address
  loanToken: Bytes! # address
  collateralToken: Bytes! # address
  repayAmount: BigInt! # uint256
  collateralWithdrawAmount: BigInt! # uint256
  collateralToLoanRate: BigInt! # uint256
  currentMargin: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type LoanSwap @entity {
  id: ID!
  loanId: Loan! # bytes32
  sourceToken: Bytes! # address
  destToken: Bytes! # address
  borrower: Bytes! # address
  sourceAmount: BigInt! # uint256
  destAmount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type PayBorrowingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type PayLendingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type PayTradingFee @entity {
  id: ID!
  payer: Bytes! # address
  token: Bytes! # address
  loanId: Loan! # bytes32
  amount: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type PayTradingFeeToAffiliate @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  isHeld: Boolean! # bool
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountPaid: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type PayTradingFeeToAffiliateFail @entity {
  id: ID!
  referrer: Bytes! # address
  trader: Bytes! # address
  token: Bytes! # address
  tradingFeeTokenAmount: BigInt! # uint256
  tokenBonusAmount: BigInt! # uint256
  sovBonusAmount: BigInt! # uint256
  sovBonusAmountTryingToPaid: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type ProtocolModuleContractReplaced @entity {
  id: ID!
  prevModuleContractAddress: Bytes! # address
  newModuleContractAddress: Bytes! # address
  module: Bytes! # bytes32
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetAffiliateFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetAffiliateTradingTokenFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetAffiliatesReferrer @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetAffiliatesReferrerFail @entity {
  id: ID!
  user: Bytes! # address
  referrer: Bytes! # address
  alreadySet: Boolean! # bool
  userNotFirstTrade: Boolean! # bool
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetBorrowingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetFeesController @entity {
  id: ID!
  sender: Bytes! # address
  oldController: Bytes! # address
  newController: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetLendingFeePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetLiquidationIncentivePercent @entity {
  id: ID!
  sender: Bytes! # address
  oldValue: BigInt! # uint256
  newValue: BigInt! # uint256
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetLoanPool @entity {
  id: ID!
  sender: Bytes! # address
  loanPool: Bytes! # address
  underlying: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type SetWrbtcToken @entity {
  id: ID!
  sender: Bytes! # address
  oldWethToken: Bytes! # address
  newWethToken: Bytes! # address
  timestamp: BigInt!
    emittedBy: Bytes! #address
    transaction: Transaction!
}

type Trade @entity {
  id: ID!
  user: User! # address
  lender: Bytes! # address
  loanId: Loan! # bytes32
  collateralToken: Bytes! # address
  loanToken: Bytes! # address
  positionSize: BigInt! # uint256
  borrowedAmount: BigInt! # uint256
  interestRate: BigInt! # uint256
  settlementDate: BigInt! # uint256
  entryPrice: BigInt! # uint256
  entryLeverage: BigInt! # uint256
  currentLeverage: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# type WithdrawFees @entity {
#   id: ID!
#   sender: Bytes! # address
#   token: Bytes! # address
#   receiver: Bytes! # address
#   lendingAmount: BigInt! # uint256
#   tradingAmount: BigInt! # uint256
#   borrowingAmount: BigInt! # uint256
#   timestamp: BigInt!
#     emittedBy: Bytes! #address
#     transaction: Transaction!
# }

# Lending Contract events

type WithdrawLendingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type WithdrawTradingFees @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type Burn @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  loanToken: LoanToken!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type FlashBorrow @entity {
  id: ID!
  user: User! # address
  target: Bytes! # address
  loanAmount: BigInt! # uint256
  loanToken: LoanToken!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  underlyingAsset: Token!
}

type Mint @entity {
  id: ID!
  user: User! # address
  tokenAmount: BigInt! # uint256
  assetAmount: BigInt! # uint256
  loanToken: LoanToken!
  price: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type LoanToken @entity {
  id: ID! #address
  underlyingAsset: Token!
}

# Vesting Resistry

type VestingContract @entity {
  id: ID! # vesting contract id
  user: User!
  createdAtTimestamp: BigInt
  cliff: BigInt # uint256
  duration: BigInt # uint256
  amount: BigInt # uint256
  type: String # Team, Non-team, Rewards
  emittedBy: Bytes!
  createdAtTransaction: Transaction!
  stakeHistory: [TokensStaked!]!
  # sovTransferred: [SOVTransferred!] @derivedFrom(field: "receiver")
}

type SOVTransferred @entity {
  id: ID!
  receiver: VestingContract! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# VestingLogic

type DividendsCollected @entity {
  id: ID!
  caller: Bytes! # address
  loanPoolToken: Bytes! # address
  receiver: User! # address
  maxCheckpoints: BigInt! # uint32
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensWithdrawn_Vesting @entity {
  id: ID!
  caller: Bytes! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking contract

type DelegateStakeChanged @entity {
  id: ID!
  delegate: Bytes! # address
  lockedUntil: BigInt! # uint256
  previousBalance: BigInt! # uint256
  newBalance: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensStaked @entity {
  id: ID!
  user: User
  staker: Bytes! # address
  amount: BigInt! # uint256
  lockedUntil: BigInt! # uint256
  totalStaked: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
  isUserStaked: Boolean!
}

type VestingTokensWithdrawn @entity {
  id: ID!
  vesting: VestingContract! # address
  receiver: Bytes! # address
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# This maps to existing stakeHistory api

type UserStakeHistory @entity {
  id: ID! # transaction hash
  user: User!
  action: String!
  timestamp: BigInt!
  transaction: Transaction!
  amount: BigInt
  lockedUntil: BigInt
}

# Fee Sharing Proxy and Fees History

# Matches feesEarnedHistory sql
type FeesEarnedHistory @entity {
  id: ID! # transaction hash
  action: String!
  user: User!
  token: Token
  amount: BigInt
  timestamp: BigInt
  transaction: Transaction!
}

# Matches liquidSovHistory sql
type LiquidSovHistory @entity {
  id: ID! #transaction hash
  action: String!
  user: User!
  sovAmount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
}

# Matches rewardHistorySql_new
type RewardHistory @entity {
  id: ID!
  action: String!
  user: User!
  amount: BigInt!
  poolToken: PoolToken
  timestamp: BigInt!
  transaction: Transaction!
}

type FeeAMMWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  converter: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type FeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type TokensTransferred @entity {
  id: ID!
  sender: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

type UserFeeWithdrawn @entity {
  id: ID!
  sender: Bytes! # address
  receiver: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Locked SOV 

type Deposited @entity {
  id: ID!
  _initiator: Bytes! # address
  _userAddress: Bytes! # address
  _sovAmount: BigInt! # uint256
  _basisPoint: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Mining Proxy

type RewardClaimed @entity {
  id: ID!
  user: Bytes! # address
  poolToken: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# Staking Reward

type RewardWithdrawn @entity {
  id: ID!
  receiver: Bytes! # address
  amount: BigInt! # uint256
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}

# TokenConverted

type TokenConverted @entity {
  id: ID!
  timestamp: BigInt!
  emittedBy: Bytes! #address
  transaction: Transaction!
}